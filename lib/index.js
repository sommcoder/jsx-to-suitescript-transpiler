import babel from "@babel/core";
import { SS } from "./ss-component-lib.js";
import process from "process";
import { ERROR } from "./errors.js";
//import { dirname, relative } from "node:path";
import { access, constants, writeFileSync, readFileSync } from "node:fs";

// COMMAND: npm run jssx <fileName>.jsx

// gets the file the user submits if it contains .jsx
let jsxFile = process.argv.find((arg) => arg.match(/^.*\.(jsx)$/)) || null;
//console.log("jsxFile:", jsxFile);

// throw error if no .jsx file submitted:
if (!jsxFile) throw ERROR.notValidFileArg(process.argv);

// get access
access(jsxFile, constants.F_OK, (err) => {
  if (err) throw ERROR.noFileAccess(jsxFile, err);
});

// let relPath = relative("/", jsxFile);
// console.log("relPath:", relPath);
// let dirName = dirname(relPath);
// console.log("dirName:", dirName);

// read file asynchronously, once babel plugin is done, swap entire Page() function with suitescriptsyntax string:

// readFile(jsxFile, (err, data) => {
//   if (err) throw err;
//   let allCode = data.toString("utf-8").split(" ");
//   console.log(allCode);
// });

let suiteScriptSyntax = ""; // the syntax string we're populating
let pageVar = ""; // global variable, needs to be accessible by Node.js
let tabCount = 0; // tracks tabs, user gets informed if a Form has under 2 tabs
let pageFunction;

let output = babel.transformFileSync(jsxFile, {
  plugins: [
    "syntax-jsx", // needed to parse the JSX code
    function jsxToSS() {
      const { types: t } = babel;

      /* WHY: 
      handles getting the props, children and parents of the node,
      then populating the component object with the values we need to get our SuiteScript calls from the SS library
      */
      function handleNode(path) {
        // CHILDREN
        path.node.children = path.node.children.filter(
          (child) => child.type !== "JSXText"
        );
        hasValidChildren(path.node.children, path.node.compType, path);

        // Arguments get passed into the methods:
        path.node.props = {
          arguments: {
            pageVar: pageVar,
          },
          methods: {},
        };
        // Handle Node props:
        let props = handleProps(
          path.node.compType,
          path.node.openingElement.attributes,
          path
        );
        // PARENT, only if JSXElement
        let parentPath = path.findParent((path) => path.isJSXElement()) || null;

        if (parentPath) {
          path.node.parentNode = parentPath.node;
          path.node.props.arguments.parentType = path.node.parentNode.compType;
          // Handle instances where Tab | FieldGroup are the parents of currNode
          if (
            path.node.parentNode.compType === "Tab" ||
            path.node.parentNode.compType === "FieldGroup"
          ) {
            path.node.props.arguments.parentId =
              path.node.parentNode.props.arguments.id;
          }
          props.parentVar = path.node.parentNode.props.arguments.varName;
        }

        // create new instance of component Object from component library:
        let compObj = SS[path.node.compType];
        // loop through props handled and assign them back to the current Node:
        for (let [key, value] of Object.entries(props)) {
          if (
            compObj.attributes.possibleVariants &&
            compObj.attributes.possibleVariants.includes(key)
          ) {
            // if key is one of the possibleVariants, assign variant to key
            path.node.variant = key;
          }
          // assign varibles to node.arguments:
          if (compObj.props.variables.hasOwnProperty(key))
            path.node.props.arguments[key] = value;
          // assign methods to node.methods:
          if (compObj.props.methods.hasOwnProperty(key))
            path.node.props.methods[key] = value;
        }
        return path.node;
      }

      // WHY: controls how props are converted into variables/id's
      function handleVars(compType, propsObj, path) {
        if (propsObj.label || propsObj.id || propsObj.title) {
          // id NOT provided && the Type is NOT a Page: create id from label or title
          if (!propsObj.id && !SS[compType].attributes.isPage) {
            propsObj.id = createCompId(propsObj.label, compType, path);
          }
          propsObj.varName = createVarName(
            propsObj.label || propsObj.id || propsObj.title,
            compType,
            path
          );
        } else propsObj.varName = `${compType}_${compStack.length}`; // component is a SELECT or special Button component
        return propsObj;
      }

      // createCompId and createVarName are fairly similar and could possibly be refactored into the same function
      // and the
      // titles are autogenerated from label attribute, label is REQUIRED in JSSX
      function createCompId(label, type, path) {
        const regex = /^[a-zA-Z_\s]+$/;
        if (label && regex.test(label)) {
          return `${
            "custpage_" +
            label
              .trim()
              .toLowerCase()
              .split(" ")
              .map((word, arr) => {
                if (word === arr[arr.length - 1] && word !== type) {
                  // if last word does not end in the type, concat type to word:
                  return (word += `_${type.toLowerCase()}`);
                } else return word;
              })
              .join("_")
          }`;
        } else {
          throw path.buildCodeFrameError(ERROR.illegalChar(label));
        }
      }

      // creates a constant variable name of each component
      function createVarName(string, type, path) {
        const regex = /^[a-zA-Z_\s]+$/;
        if (regex.test(string)) {
          return string
            .trim()
            .toLowerCase()
            .split(" ")
            .map((word, i, arr) => {
              if (i !== 0) {
                return (
                  word.charAt(0).toUpperCase() + word.slice(1, word.length)
                );
              } else if (word === arr[arr.length - 1] && word !== type) {
                return (word += type);
              } else return word;
            })
            .join("");
        } else {
          throw path.buildCodeFrameError(ERROR.illegalChar(string));
        }
      }

      //////////////////////////////////////////////
      /* Gets the SS syntax by passing arguments into methods returning dynamic string literals */
      function getSSComponentCalls(currNode) {
        // PAGE COMPONENT:
        if (SS[currNode.compType].attributes.isPage) {
          suiteScriptSyntax = `---\n ${SS[currNode.compType].add(
            currNode.props.arguments
          )}`;
        } else {
          // COMPONENT VARIANTS:
          if (currNode.variant) {
            suiteScriptSyntax += `\n\n ${SS[currNode.compType].props.methods[
              currNode.variant
            ](currNode.props.arguments)}`;
          } else {
            // NON PAGE COMPONENT:
            suiteScriptSyntax += `\n\n ${SS[currNode.compType].add(
              currNode.props.arguments
            )}`;

            // HANDLE OTHER METHOD CALLS:
            // loop through other method calls (aside for .add() and variant methods):
            if (Object.keys(currNode.props.methods).length > 0) {
              for (let [key, value] of Object.entries(currNode.props.methods)) {
                suiteScriptSyntax += `\n\n ${SS[
                  currNode.compType
                ].props.methods[key](currNode.props.arguments, value)}`;
              }
            }
          }
        }
        return suiteScriptSyntax;
      }

      // Child Check:
      function hasValidChildren(childNamesArr, compType, path) {
        if (
          !childNamesArr.every((child) =>
            SS[compType].attributes.possibleChildren.includes(
              child.openingElement.name.name
            )
          )
        ) {
          throw path.buildCodeFrameError(
            `ERR: there is an invalid child in the component: '${compType}`
          );
        }
      }

      function handleProps(compType, propsArr, path) {
        let propsObj = {}; // To populate per JSXElement visit

        propsArr.forEach((prop) => {
          const propName = prop.name.name;
          // won't exist for some Nodes:
          //////////////////////////////
          const propValNode = prop.value;
          const propValExp = prop.value ? prop.value.expression : null;
          //////////////////////////////

          // !GUARD CLAUSES:
          if (propsObj.hasOwnProperty(propName)) {
            throw path.buildCodeFrameError(ERROR.duplicateProp(prop, compType));
          }
          if (
            !SS[compType].props.variables.hasOwnProperty(propName) &&
            !SS[compType].props.methods.hasOwnProperty(propName)
          ) {
            throw path.buildCodeFrameError(ERROR.invalidProp(prop, compType));
          }

          // !PROP HANDLING:
          // eg. disable | mandatory | selected | hidden
          if (propName && propValNode === null) {
            propsObj[propName] = true;
            return;
          }
          // eg: prop="yourprop"
          if (t.isStringLiteral(propValNode)) {
            propsObj[propName] = propValNode.value;
            return;
          }
          // eg: prop={123}
          if (
            t.isJSXExpressionContainer(propValNode) &&
            t.isNumericLiteral(propValExp)
          ) {
            propsObj[propName] = propValExp.value;
            return;
          }
          // Props w. Bindings in function scope
          if (
            t.isJSXExpressionContainer(propValNode) &&
            t.isIdentifier(propValExp)
          ) {
            const identifiersObj = path.scope.bindings;

            if (Object.keys(identifiersObj).length !== 0) {
              /* 
              if the identifiersObj doesn't contain our prop name
              it means its NOT a function scope binding, 
              but is a JSXExpContainer with an identifier within it.
              ie. a binding that is out of function lexical scope.
              */
              if (!identifiersObj[propValExp.name]) {
                //  console.log("propValExp.name", propValExp.name);
                propsObj[propName] = propValExp.name;
              } else {
                let bindingIdNode = identifiersObj[propValExp.name].path.node;
                // console.log("bindingIdNode", bindingIdNode);
                propsObj[propName] = bindingIdNode.init.value;
              }
              return;
            }
          }
        });
        // once props have been handled, pass to handleVars to create vars:
        return handleVars(compType, propsObj, path);
      }
      const compStack = [];
      return {
        name: "jssx",
        visitor: {
          JSXElement(path) {
            let compType = path.node.openingElement.name.name;
            if (compType === "Tab") tabCount++; // tab tracking:
            path.node.compType = compType;
            // PascalCase check:
            if (compType.charAt(0) !== compType.charAt(0).toUpperCase()) {
              throw path.buildCodeFrameError(ERROR.invalidCase(compType));
            }
            // Attribute/Prop check:
            if (path.node.openingElement.attributes.length < 1) {
              throw path.buildCodeFrameError(ERROR.noProps(compType));
            }
            let currNode = handleNode(path);
            // set pageVar for child components to reference easily
            if (compStack.length === 0) {
              pageVar = currNode.props.arguments.varName;
            }
            compStack.push(currNode);
            let ss = getSSComponentCalls(currNode, path);
            // console.log("suiteScriptSyntax:", ss);

            const NODE = babel.template.ast(ss);
            // console.log("NODE:", NODE);
            path.replaceWith(NODE);
          },
        },
      };
    },
  ],
  comments: false,
});

suiteScriptSyntax += `\n\n${SS.Write(pageVar)}\n---`;
console.log(suiteScriptSyntax);

// let jsFile = jsxFile.replace(".jsx", ".js");

// if (access(jsFile)) {
//   console.log("jsFile Exists");
//   // replace exising code
//   let jsFileCode = readFileSync(jsFile, _, (err) => {
//     jsFileCode.replace("");
//     if (err) throw err;
//     console.log("the file has been read");
//   });
// } else {
//   // create js file
//   // add babel output
//   writeFileSync(jsFile, suiteScriptSyntax, (err) => {
//     if (err) throw err;
//     console.log("the file has been written");
//   });
// }

// create an fs.watch() to listen for changes on the code.jsx file
/*
 
fs.watch('somedir', (eventType, filename) => {

!  if .jsx file name changes, change the name of the .js file as well?
  console.log(`event type is: ${eventType}`);
  if (filename) {
    console.log(`filename provided: ${filename}`);
  } else {
    console.log('filename not provided');
  }
}); 



*/

// console.log("output.code:", output.code);
// if (tabCount < 2 && pageVar === "Form") {
//   console.log(
//     "JSSX transpiled, however there aren't enough tab components for this Page. There must be a minimum of 2 tabs to a Form."
//   );
// }

// console.log("output.code:", output.code);

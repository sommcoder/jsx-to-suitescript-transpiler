import babel from "@babel/core";
import { SS } from "./ss-component-lib.js";
// import * as util from "./util.js";

// const { template } = babel;

const ui = "ui";

const output = babel.transformFileSync("code.jsx", {
  plugins: ["syntax-jsx", jsxToSS],
});

function jsxToSS() {
  const { types: t } = babel;

  const ERROR = {
    illegalChar: (label) =>
      `ERROR: jsx label: ${label} contains special characters that are not permitted`,
    invalidComp: (compType) =>
      `ERR: the jsx component: ${compType}, is NOT included in the ss library. Refer to docs to see included components`,
  };

  function handleNode(path) {
    console.log("createCompObj NODE BEFORE:", path.node);
    // Initial Setup:
    // CHILDREN, remove JSXText components
    path.node.children = path.node.children.filter(
      (child) => child.type !== "JSXText"
    );
    // children Check:
    hasValidChildren(path.node.children, path.node.compType, path);

    // Arguments get passed into the methods:
    path.node.props = {
      arguments: {},
      methods: {},
    };
    // Handle Node props:
    let props = handleProps(
      path.node.compType,
      path.node.openingElement.attributes,
      path
    );

    // PARENT, only if JSXElement
    let parentPath = path.findParent((path) => path.isJSXElement()) || null;
    if (parentPath) {
      path.node.parentNode = parentPath.node;
      props.parentVar = path.node.parentNode.props.arguments.varName;
      console.log("props.parentVar", props.parentVar);
    } else path.node.parentNode = parentPath;

    // create new instance of component Object from component library:
    let compObj = SS[path.node.compType];
    // loop through props handled and assign them back to the current Node:
    for (let [key, value] of Object.entries(props)) {
      console.log("key:", key, ", value:", value);
      if (
        compObj.attributes.possibleVariants &&
        compObj.attributes.possibleVariants.includes(key)
      ) {
        // if key is one of the possibleVariants, assign variant to key
        path.node.variant = key;
      }
      // assign varibles to node.arguments:
      if (compObj.props.variables.hasOwnProperty(key))
        path.node.props.arguments[key] = value;
      // assign methods to node.methods:
      if (compObj.props.methods.hasOwnProperty(key))
        path.node.props.methods[key] = value;
    }
    return path.node;
  }

  // controls how props are converted into variables/id's
  function handleVars(compType, propsObj, path) {
    // console.log("handleVars propsObj:", propsObj);
    //console.log("SS[compType]", SS[compType]);
    if (propsObj.label || propsObj.id || propsObj.title) {
      // id NOT provided && the Type is NOT a Page: create id from label or title
      if (!propsObj.id && !SS[compType].attributes.isPage) {
        propsObj.id = createCompId(propsObj.label, compType, path);
      }
      propsObj.varName = createVarName(
        propsObj.label || propsObj.id || propsObj.title,
        compType,
        path
      );
    } else propsObj.varName = `${compType}_${n++}`; // component is a SELECT or special Button component
    return propsObj;
  }

  // createCompId and createVarName are fairly similar and could possibly be refactored into the same function
  // and the
  // titles are autogenerated from label attribute, label is REQUIRED in JSSX
  function createCompId(label, type, path) {
    //  console.log("id: label:", label);
    const regex = /^[a-zA-Z_\s]+$/;
    if (label && regex.test(label)) {
      return `${
        "custpage_" +
        label
          .trim()
          .toLowerCase()
          .split(" ")
          .map((word, arr) => {
            if (word === arr[arr.length - 1] && word !== type) {
              // if last word does not end in the type, concat type to word:
              return (word += `_${type.toLowerCase()}`);
            } else return word;
          })
          .join("_")
      }`;
    } else {
      throw path.buildCodeFrameError(ERROR.illegalChar(label));
    }
  }

  // creates a constant variable name of each component
  function createVarName(string, type, path) {
    //console.log("varName: string:", string);
    const regex = /^[a-zA-Z_\s]+$/;
    // No special character, underscore is allowed
    if (regex.test(string)) {
      // console.log("string", string);
      return string
        .trim()
        .toLowerCase()
        .split(" ")
        .map((word, i, arr) => {
          // if NOT first word, make 1st letter uppercase
          if (i !== 0) {
            return word.charAt(0).toUpperCase() + word.slice(1, word.length);
          } else if (word === arr.at(-1) && word !== type) {
            // if last word does not end in the type, concat type to word:
            return (word += type);
          } else return word;
        })
        .join("");
    } else {
      throw path.buildCodeFrameError(ERROR.illegalChar(string));
    }
  }

  //////////////////////////////////////////////
  // EXPORTED FUNCTIONS to INDEX.JS
  function getSSComponentCalls(currNode, path) {
    console.log("currNode (SS Component Calls:", currNode);
    let suiteScriptSyntax;

    // CREATE PAGE COMPONENT:
    if (SS[currNode.compType].attributes.isPage) {
      console.log("PAGE COMPONENT!");
      suiteScriptSyntax = SS[currNode.compType].add(
        ui,
        currNode.props.arguments
      ); // initial syntax assignment
    } else {
      // CREATE NOT PAGE COMPONENT:
      // is COMPONENT a VARIANT?:
      if (currNode.variant) {
        console.log("Node is a variant");
        suiteScriptSyntax += `\n\n ${SS[currNode.compType].props.methods[
          currNode.variant
        ](currNode.props.arguments)}`;
      } else {
        console.log("Node is NOT a variant");
        suiteScriptSyntax += `\n\n ${SS[currNode.compType].add(
          currNode.props.arguments
        )}`;
      }
    }
    // HANDLE OTHER METHOD CALLS:
    // loop through other method calls (aside for .add() and variant methods):
    if (Object.keys(currNode.props.methods).length > 0) {
      console.log("has additional methods!");
      for (let [key, value] of Object.entries(currNode.props.methods)) {
        console.log("key:", key, "value:", value);
        suiteScriptSyntax +
          `\n\n ${SS[currNode.compType].props.methods[key](
            currNode.props.arguments
          )}`;
      }
    }
    console.log("suiteScriptSyntax:", suiteScriptSyntax);
    return suiteScriptSyntax;
  }

  // Function NOT being used currently!
  // Function NOT being used currently!
  function hasValidChildren(childNamesArr, compType, path) {
    console.log(compType);
    console.log(childNamesArr);
    if (
      !childNamesArr.every((child) =>
        SS[compType].attributes.possibleChildren.includes(
          child.openingElement.name.name
        )
      )
    ) {
      throw path.buildCodeFrameError(
        `ERR: there is an invalid child in the component: '${compType}`
      );
    } else {
      // console.log("good kids");
    }
  }

  function handleProps(compType, propsArr, path) {
    let propsObj = {}; // new props object per component visit
    //console.log('comptype:', compType);
    // console.log("propsArr:", propsArr);
    propsArr.forEach((prop) => {
      const propName = prop.name.name;
      const propValNode = prop.value; // won't exist for some Nodes
      const propValExp = prop.value ? prop.value.expression : null; //  won't exist for some Nodes
      //  console.log("prop", prop);
      // valid prop of component in component library?
      //console.log(SS[comp].props.variables.hasOwnProperty(propName));
      /*
      if (!SS[compType].props.variables.hasOwnProperty(propName) && !SS[compType].props.methods.hasOwnProperty(propName)) {
        throw path.buildCodeFrameError(`ERR: The prop called: '${propName}' is NOT a valid prop in the component: '${compType}'`);
      }
      */

      // is prop duplicate?
      if (propsObj.hasOwnProperty(propName)) {
        throw path.buildCodeFrameError(
          `ERR: there is already an prop called: '${propName}' in the component: '${compType}. There cannot be duplicate props in a component'`
        );
      }
      // (ie. disable/mandatory/selected/hidden)
      if (propValNode === null) {
        propsObj[propName] = true;
        return;
      }
      // eg: prop="yourprop"
      if (t.isStringLiteral(propValNode)) {
        propsObj[propName] = propValNode.value;
        return;
      }
      // eg: prop={123}
      if (
        t.isJSXExpressionContainer(propValNode) &&
        t.isNumericLiteral(propValExp)
      ) {
        propsObj[propName] = propValExp.value;
        return;
      }
      // Props w. Bindings (IN FUNCTION SCOPE)
      // Could we use t.isBinding() instead?
      if (
        t.isJSXExpressionContainer(propValNode) &&
        t.isIdentifier(propValExp)
      ) {
        const identifiersObj = path.scope.bindings;
        // if the identifier object has props:
        if (Object.keys(identifiersObj).length !== 0) {
          let bindingIdNode = identifiersObj[propValExp.name].path.node;
          propsObj[propName] = bindingIdNode.init.value;
          return;
        }
        // Props w. Bindings (OUTSIDE FUNCTION SCOPE) how do????????
        // Could we use t.isBinding() for this?
      }
    });
    //console.log("handleProps:", propsObj);
    //console.log("handleVars return: ", handleVars(compType, propsObj, path));
    return handleVars(compType, propsObj, path);
  }
  //////////////////////////////////////////////////////////////
  /////////////////// PLUGIN ///////////////////////////////////
  //////////////////////////////////////////////////////////////
  let pageVar = "";
  let n = 1;
  const pageStack = [];

  return {
    name: "jssx",
    visitor: {
      FunctionDeclaration(path) {
        // if function declaration has a return statement with an argument of JSXElement, path.replaceWith('') empty string.
        // AND get any variable declarations,  path.replaceWith('') empty string.
        // AND get the return statement,  path.replaceWith('') empty string.
      },
      JSXElement(path) {
        let compType = path.node.openingElement.name.name;
        path.node.compType = compType;
        // PascalCase check:
        if (compType.charAt(0) !== compType.charAt(0).toUpperCase()) {
          throw path.buildCodeFrameError(
            `ERROR: jsx compType: ${path.node.compType} needs to be in PascalCase with the first letter capitalized!`
          );
        }

        let propsArr = path.node.openingElement.attributes;
        if (!propsArr)
          throw path.buildCodeFrameError(
            `ERROR: jssx compType: ${compType} does not have any attributes and therefore is void!`
          );

        let currNode = handleNode(path);
        console.log("handleNode NODE AFTER:", currNode);

        // set pageVar for child components to reference easily
        if (pageStack.length === 0) {
          pageVar = currNode.props.arguments.varName;
        }
        pageStack.push(currNode);
        let ss = getSSComponentCalls(currNode, path);
        const NODE = babel.template.statement.ast`${ss}`;
        console.log(NODE);
        //path.replaceWith(NODE);
        //path.skip();
      },
    },
  };
}

// function transpile(moduleCode) {
//   const { code } = babel.transform(moduleCode);
//   return code;
// }

// transpile(output.code)

console.log("output.code:", output.code);
console.log("output.ast:", output.ast);
console.log("output.map:", output.map);

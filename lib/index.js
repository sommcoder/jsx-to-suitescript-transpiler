import babel from "@babel/core";
import { SS } from "./ss-component-lib.js";
import process from "process";
import { ERROR } from "./errors.js";
import fs from "fs";

// how do we allow users to enter the file they want and GET that file and use as a variable

// COMMAND: npm run jssx --code.jsx
// apparently -- is not needed?

console.log("process.argv:", process.argv);

let jsxFile = process.argv.find((arg) => arg.match(/^.*\.(jsx)$/)) || null;
console.log("jsxFile:", jsxFile);

if (!jsxFile) {
  console.log(ERROR.notValidFileArg(process.argv));
  process.exit();
}

// read file asynchronously, once babel plugin is done, swap Page() component with suitescriptsyntax string:
//fs.readFile((jsxFile, function () {}));

let suiteScriptSyntax; // the syntax string we're populating
let pageVar = ""; // global variable, needs to be accessible by Node.js

babel.transformFileSync(jsxFile, {
  plugins: [
    "syntax-jsx", // needed to parse the JSX code
    function jsxToSS() {
      const { types: t } = babel;

      /* WHY: handles getting the props, children and parents of the node
              then populating the component object with the values we need to get our SuiteScript calls
      */
      function handleNode(path) {
        // CHILDREN
        path.node.children = path.node.children.filter(
          (child) => child.type !== "JSXText"
        );
        hasValidChildren(path.node.children, path.node.compType, path);

        // Arguments get passed into the methods:
        path.node.props = {
          arguments: {
            pageVar: pageVar,
          },
          methods: {},
        };
        // Handle Node props:
        let props = handleProps(
          path.node.compType,
          path.node.openingElement.attributes,
          path
        );
        //  console.log("props HANDLE NODE:", props);
        // PARENT, only if JSXElement
        let parentPath = path.findParent((path) => path.isJSXElement()) || null;
        // console.log("parentPath", parentPath);
        if (parentPath) {
          path.node.parentNode = parentPath.node;
          props.parentVar = path.node.parentNode.props.arguments.varName;
          props.parentId = path.node.parentNode.props.arguments.id;
          //  console.log("props.parentVar", props.parentVar);
        }
        /* 
      How are we going to handle Tabs since <Tab> would be the parent for <Field> but there is 
      no Tab.addField().. maybe we create a variant... 
      
      - Firstly, lets look into the SuiteScript code for Tab
      - when sublist is given a tab value, skip
      - If parent is Tab: path.node.props.tab = tabId
      */
        // create new instance of component Object from component library:
        let compObj = SS[path.node.compType];
        // loop through props handled and assign them back to the current Node:
        for (let [key, value] of Object.entries(props)) {
          //  console.log("key:", key, ", value:", value);
          if (
            compObj.attributes.possibleVariants &&
            compObj.attributes.possibleVariants.includes(key)
          ) {
            // if key is one of the possibleVariants, assign variant to key
            path.node.variant = key;
          }
          // assign varibles to node.arguments:
          if (compObj.props.variables.hasOwnProperty(key))
            path.node.props.arguments[key] = value;
          // assign methods to node.methods:
          if (compObj.props.methods.hasOwnProperty(key))
            path.node.props.methods[key] = value;
        }
        return path.node;
      }

      // WHY: controls how props are converted into variables/id's
      function handleVars(compType, propsObj, path) {
        if (propsObj.label || propsObj.id || propsObj.title) {
          // id NOT provided && the Type is NOT a Page: create id from label or title
          if (!propsObj.id && !SS[compType].attributes.isPage) {
            propsObj.id = createCompId(propsObj.label, compType, path);
          }
          propsObj.varName = createVarName(
            propsObj.label || propsObj.id || propsObj.title,
            compType,
            path
          );
        } else propsObj.varName = `${compType}_${compStack.length}`; // component is a SELECT or special Button component
        return propsObj;
      }

      // createCompId and createVarName are fairly similar and could possibly be refactored into the same function
      // and the
      // titles are autogenerated from label attribute, label is REQUIRED in JSSX
      function createCompId(label, type, path) {
        const regex = /^[a-zA-Z_\s]+$/;
        if (label && regex.test(label)) {
          return `${
            "custpage_" +
            label
              .trim()
              .toLowerCase()
              .split(" ")
              .map((word, arr) => {
                if (word === arr[arr.length - 1] && word !== type) {
                  // if last word does not end in the type, concat type to word:
                  return (word += `_${type.toLowerCase()}`);
                } else return word;
              })
              .join("_")
          }`;
        } else {
          throw path.buildCodeFrameError(ERROR.illegalChar(label));
        }
      }

      // creates a constant variable name of each component
      function createVarName(string, type, path) {
        const regex = /^[a-zA-Z_\s]+$/;
        if (regex.test(string)) {
          return string
            .trim()
            .toLowerCase()
            .split(" ")
            .map((word, i, arr) => {
              if (i !== 0) {
                return (
                  word.charAt(0).toUpperCase() + word.slice(1, word.length)
                );
              } else if (word === arr[arr.length - 1] && word !== type) {
                return (word += type);
              } else return word;
            })
            .join("");
        } else {
          throw path.buildCodeFrameError(ERROR.illegalChar(string));
        }
      }

      //////////////////////////////////////////////
      /* Gets the SS syntax by passing arguments into methods returning dynamic string literals */
      function getSSComponentCalls(currNode) {
        // console.log("currNode (SS Component Calls:", currNode);

        // PAGE COMPONENT:
        if (SS[currNode.compType].attributes.isPage) {
          suiteScriptSyntax = `\n ${SS[currNode.compType].add(
            currNode.props.arguments
          )}`;
        } else {
          // COMPONENT VARIANTS:
          if (currNode.variant) {
            suiteScriptSyntax += `\n\n ${SS[currNode.compType].props.methods[
              currNode.variant
            ](currNode.props.arguments)}`;
          } else {
            // NON PAGE COMPONENT:
            suiteScriptSyntax += `\n\n ${SS[currNode.compType].add(
              currNode.props.arguments
            )}`;

            // HANDLE OTHER METHOD CALLS:
            // loop through other method calls (aside for .add() and variant methods):
            if (Object.keys(currNode.props.methods).length > 0) {
              // console.log("has additional methods!");
              for (let [key, value] of Object.entries(currNode.props.methods)) {
                // console.log("key:", key, "value:", value);
                suiteScriptSyntax += `\n\n ${SS[
                  currNode.compType
                ].props.methods[key](currNode.props.arguments, value)}`;
              }
            }
          }
        }
        // console.log("suiteScriptSyntax:", suiteScriptSyntax);

        return suiteScriptSyntax;
      }

      // Child Check:
      function hasValidChildren(childNamesArr, compType, path) {
        if (
          !childNamesArr.every((child) =>
            SS[compType].attributes.possibleChildren.includes(
              child.openingElement.name.name
            )
          )
        ) {
          throw path.buildCodeFrameError(
            `ERR: there is an invalid child in the component: '${compType}`
          );
        }
      }

      function handleProps(compType, propsArr, path) {
        let propsObj = {}; // new props object to populate / JSXElement visit

        propsArr.forEach((prop) => {
          const propName = prop.name.name;
          const propValNode = prop.value; // won't exist for some Nodes
          const propValExp = prop.value ? prop.value.expression : null; //  won't exist for some Nodes
          console.log("prop", prop);

          // !GUARD CLAUSES:
          if (propsObj.hasOwnProperty(propName)) {
            throw path.buildCodeFrameError(ERROR.duplicateProp(prop, compType));
          }
          if (
            !SS[compType].props.variables.hasOwnProperty(propName) &&
            !SS[compType].props.methods.hasOwnProperty(propName)
          ) {
            throw path.buildCodeFrameError(ERROR.invalidProp(prop, compType));
          }

          // !PROP HANDLING:
          // eg. disable | mandatory | selected | hidden
          if (propName && propValNode === null) {
            propsObj[propName] = true;
            return;
          }
          // eg: prop="yourprop"
          if (t.isStringLiteral(propValNode)) {
            propsObj[propName] = propValNode.value;
            return;
          }
          // eg: prop={123}
          if (
            t.isJSXExpressionContainer(propValNode) &&
            t.isNumericLiteral(propValExp)
          ) {
            propsObj[propName] = propValExp.value;
            return;
          }
          // Props w. Bindings in function scope
          if (
            t.isJSXExpressionContainer(propValNode) &&
            t.isIdentifier(propValExp)
          ) {
            const identifiersObj = path.scope.bindings;

            if (Object.keys(identifiersObj).length !== 0) {
              /* 
           if the identifiersObj doesn't contain our prop name
           it means its NOT a function scope binding, 
           but is a JSXExpContainer with an identifier within it.
           ie. a binding that is out of function lexical scope.
          */
              if (!identifiersObj[propValExp.name]) {
                //  console.log("propValExp.name", propValExp.name);
                propsObj[propName] = propValExp.name;
              } else {
                let bindingIdNode = identifiersObj[propValExp.name].path.node;
                // console.log("bindingIdNode", bindingIdNode);
                propsObj[propName] = bindingIdNode.init.value;
              }
              return;
            }
          }
          // if path has serverWidget binding? Assign serverWidget
          // is there a better way of doing this? Maybe user doesn't define the serverWidget variable as serverWidget?
          //if (path.scope.hasBinding("serverWidget")) {
          //  propsObj[propName] = "serverWidget";
          // return;
          //  }
        });

        // once props have been handled, pass to handleVars to create vars:
        return handleVars(compType, propsObj, path);
      }
      //////////////////////////////////////////////////////////////
      /////////////////// PLUGIN ///////////////////////////////////
      //////////////////////////////////////////////////////////////
      const compStack = [];

      return {
        name: "jssx",
        visitor: {
          JSXElement(path) {
            let compType = path.node.openingElement.name.name;
            path.node.compType = compType;
            // PascalCase check:
            if (compType.charAt(0) !== compType.charAt(0).toUpperCase()) {
              throw path.buildCodeFrameError(ERROR.invalidCase(compType));
            }
            // Attribute/Prop check:
            if (!path.node.openingElement.attributes) {
              throw path.buildCodeFrameError(ERROR.noProps(compType));
            }

            let currNode = handleNode(path);

            // set pageVar for child components to reference easily
            if (compStack.length === 0)
              pageVar = currNode.props.arguments.varName;

            compStack.push(currNode);

            let ss = getSSComponentCalls(currNode, path);
            const NODE = babel.template.statement.ast`${ss}`;
            console.log("NODE", NODE);
          },
        },
      };
    },
  ],
});

suiteScriptSyntax += SS.Write(pageVar);

console.log(suiteScriptSyntax);

// function transpile(moduleCode) {
//   const { code } = babel.transform(moduleCode);
//   return code;
// }

// transpile(output.code)

exports.default = createPlugin;

const ui = "ui";

function createPlugin(babel) {
  const { types: t } = babel;

  const { template } = babel;
  //console.log("template", template);
  //console.log(template.ast);

  //////////////////////////// SUITESCRIPT LIBRARY
  const SS = {
    Form: {
      // ui comes from outside the scope of the component function
      add: (ui, props) => {
        return `const ${props.varName} = ${ui}.createForm({
        title: '${props.title}',
      });`;
      },
      attributes: {
        isPage: true,
        possibleChildren: ["Sublist", "Field", "Button", "Tab", "FieldGroup"],
        possibleParents: null,
      },
      props: {
        variables: {
          parentVar: null,
          varName: null,
          title: null,
          module: null,
          fileId: null,
          navBar: null,
        },
        methods: {
          module: (props) =>
            `${props.pageVar}.clientScriptModulePath = '${props.path}';`,
          fileId: (props) =>
            `${props.pageVar}.clientScriptFileId = '${props.id}';`,
          navBar: (props) =>
            `${props.pageVar}.clientScriptFileId = '${props.id}';`,
        },
      },
    },
    List: {},
    Assistant: {},
    Tab: {
      /*
      Tabs are special!
      
      -to enable tab to appear on your form, there must be at LEAST one component assigned to the tab
      -if < 2 tabs on form, the tab will not appear. this is SS logic, transpile normally!
      -Should throw WARNING for developer, but still transpile to SuiteScript^^^

      */
      add: (props) => {
        return `const ${props.varName} = ${props.pageVar}.addTab({
      id: '${props.id}',
      label: '${props.label}',
    });`;
      },
      attributes: {
        isPage: false,
        possibleChildren: ["Field", "Button", "Sublist"],
        possibleParents: ["Form"],
      },
      props: {
        variables: {
          varName: null,
          parentVar: null,
          id: null,
          label: null,
          tab: null,
        },
        methods: {
          help: (props) => `${props.varName}.helpText = '${props.help}'`,
        },
      },
    },
    // PascalCase
    FieldGroup: {
      add: (props) => {
        return `const ${props.varName} = ${props.pageVar}.addFieldGroup({
        id: '${props.id}',
        label: '${props.label}',
        ${props.tab ? `tab: ${props.tab}` : ""}
     })
    `;
      },
      attributes: {
        isPage: false,
        possibleChildren: ["Field", "Button"],
        possibleParents: ["Form", "Assistant"],
      },
      props: {
        variables: {
          parentVar: null,
          varName: null,
          id: null,
          label: null,
          tab: null,
        },
        methods: {
          single: (props) => `${props.name}.isSingleColumn;`,
          collapsible: (props) => `${props.name}.isCollapsible = true;`,
          collapsed: (props) => `${props.name}.isCollapsed;`,
          borderHidden: (props) => `${props.name}.isBorderHidden = true;`,
        },
      },
    },
    Sublist: {
      add: (props) => {
        return `const ${props.varName} = ${props.pageVar}.addSublist({
      id: '${props.id}',
      label: '${props.label}',${props.type ? `\n type: ${props.type},` : ""}${
          props.tab ? `\n tab: ${props.tab}` : ""
        }
    });`;
      },
      attributes: {
        isPage: false,
        possibleChildren: ["Field", "Button"],
        possibleParents: ["Form", "Assistant", "List", "Tab"],
      },
      props: {
        // props are what are encapsulated in each JSSX component tag
        variables: {
          label: null, // what the user wants to call the component
          type: null, // the type of component
          id: null, // the autogenerated id
          tab: null, // the tab variable that the component belongs to, inferred?
          parentVar: null,
          varName: null,
          pageVar: null,
        },
        methods: {
          markAll: (props) => `${props.varName}.addMarkAllButtons();`,
        },
      },
    },
    Field: {
      add: (props) => {
        return `const ${props.varName} = ${props.parentVar}.addField({
        id: '${props.id}',
        ${
          props.label ? `label: '${props.label}'` : `label: '${props.varName}'`
        },${props.type ? `\n type: '${props.type}',` : ""}${
          props.source ? `\n source: '${props.source}',` : ""
        }
		${props.container ? `\n container: '${props.container}',` : ""}
      });`;
      },
      attributes: {
        isPage: false,
        possibleChildren: ["Select"],
        possibleParents: ["Form", "Assistant", "Tab", "Sublist", "List"],
        possibleVariants: ["secret", "totalling", "unique"],
      },
      props: {
        variables: {
          label: null,
          type: null,
          id: null,
          parentVar: null,
          parentId: null,
          pageVar: null,
          varName: null,
          source: null,
          container: null,
          breakType: null,
        },
        methods: {
          credential: (props) => {
            return `const ${props.varName} = ${
              props.pageVar
            }.addCredentialField({
        id: '${props.id}',
        restrictToDomains: '${props.domain}',
        ${props.scriptIds ? `restrictToScriptIds : '${props.scriptIds}'` : ""},
        ${props.restUser ? `restrictToCurrentUser : '${props.restUser}'` : ""},
        ${props.container ? `container: '${props.container}'` : ""}
        })`;
          },

          breakType: (props) => {
            return `${props.varName}.updateBreakType({
              breakType: ${props.breakType}
            });`;
          },
          // example:    size={height: 40, width: 50}
          size: (props) => {
            return `${props.varName}.updateDisplaySize({
                  height: ${props.size.height},
                  width: ${props.size.width}
              });`;
          },
          layout: (props) => {},
          alias: (props) => {},
          def: (props) => `${props.field}.defaultValue = '${props.def}';`,
          help: (props) => {
            return `${props.field}.setHelpText({
    		    help: '${props.help}'
  			    });
  		      `;
          },
          mandatory: (props) =>
            `${props.field}.isMandatory = ${props.mandatory};`,
          link: (props) => `${props.varName}.linkText = '${props.link}';`,
          max: (props) => `${props.field}.maxLength = ${props.max};`,
          padding: (props) => `${props.varName}.padding = ${props.padding}`,
          // secret is a special variant of field
          // it's parent MUST BE a page a secret field cannot be nested in non-page components

          // special Field component variants:
          // if nested in a fieldGroup or Tab, this parent will be inferred as the container and props.parentId will be the value container is given
          secret: (props) => {
            return `const ${props.varName} = ${
              props.pageVar
            }.addSecretKeyField({
              id: '${props.id}',
              ${props.label ? `label: '${props.label}'` : `label: ${props.id}`},
              ${
                props.scriptIds
                  ? `restrictToScriptIds: '${props.scriptIds}',`
                  : ""
              }
              ${
                props.restUser
                  ? `restrictToCurrentUser: '${props.restUser}',`
                  : ""
              },
               ${props.container ? `container: '${props.parentId}',` : ""},
            });
  `;
          },
          // the id of the field:
          totalling: (props) => {
            return `${props.sublistVar}.updateTotallingField({
      id: '${props.id}',
})`;
          },
          unique: (props) => {
            return `${props.sublistVar}.updateUniqueFieldId({
  id: '${props.id}',
})`;
          },
        },
      },
    },

    Select: {
      add: (props) => {
        return `${props.parentVar}.addSelectOption({
                  value : '${props.value}',
                  text : '${props.text}',${
          props.isSelected ? `\n isSelected: true` : ""
        }
            });`;
      },
      attributes: {
        isPage: false,
        possibleChildren: null,
        possibleParents: ["Field"],
      },
      props: {
        variables: {
          isSelected: false,
          value: null,
          text: null,
          varName: null,
          parentVar: null, // can only be Field anyways
        },
        methods: {},
      },
    },
    Button: {
      add: (props) => {
        return `const ${props.varName} = ${props.parentVar}.addButton({
                  id: '${props.id}',
                  ${
                    props.label
                      ? `label: '${props.label}'`
                      : `label: '${props.id}'`
                  },
				  ${props.parent === "Form" && props.func ? `func: ${props.func}` : ""}
              });`;
      },
      attributes: {
        isPage: false,
        possibleChildren: null,
        possibleParents: ["Field", "Form", "Assistant", "Sublist"],
        possibleVariants: ["hidden", "submit", "reset"],
      },
      props: {
        variables: {
          label: null,
          id: null,
          parentVar: null,
          varName: null, // the variable name of this button component
          pageVar: null, // the variable name of the page the button belongs to
          func: null,
        },
        methods: {
          disabled: (props) =>
            `${props.buttonVar}.clientScriptModulePath = '${props.path}';`,
          hidden: (props) =>
            `${props.buttonVar}.clientScriptFileId = '${props.id}';`,
          // if submit, id disregarded, label accepted only, default: "Submit Button"
          submit: (props) => {
            return `const ${props.varName || "submitBtn"} = ${
              props.parentVar
            }.addSubmitButton({
            ${
              props.label ? `label: '${props.label}'` : `label: "Submit Button"`
            },
          });
          `;
          },
          // if reset, id disregarded, label accepted only, default: "Reset Button"
          // parent MUST be a Page
          reset: (props) => {
            return `const ${props.varName || "resetBtn"} = ${
              props.parentVar
            }.addResetButton({
            ${
              props.label ? `label: '${props.label}'` : `label: "Reset Button"`
            },
          });
          `;
          },
          // if reset, id AND label disregarded,
          refresh: (props) =>
            `const ${props.varName || "refreshBtn"} = ${
              props.parentVar
            }.addRefreshButton();`,
        },
      },
    },
    // creates the Page, whether thats a Form, List or Assistant
    // always gets called in the plugin
    Write: (res, props) => {
      return `
    ${res}.writePage({
        pageObject: ${props.pageVar}
    })  
`;
    },
  };
  ////////////////////////////////////////////////////////////////////
  ////////////////////////// UTILITY FUNCTIONS ///////////////////////

  const ERROR = {
    illegalChar: (label) =>
      `ERROR: jsx label: ${label} contains special characters that are not permitted`,
    invalidComp: (compType) =>
      `ERR: the jsx component: ${compType}, is NOT included in the ss library. Refer to docs to see included components`,
  };

  function handleNode(path) {
    console.log("createCompObj NODE BEFORE:", path.node);
    // Initial Setup:
    // CHILDREN, remove JSXText components
    path.node.children = path.node.children.filter(
      (child) => child.type !== "JSXText"
    );
    // Arguments get passed into the methods:
    path.node.props = {
      arguments: {},
      methods: {},
    };
    // Handle Node props:
    let props = handleProps(
      path.node.compType,
      path.node.openingElement.attributes,
      path
    );

    // PARENT, only if JSXElement
    let parentPath = path.findParent((path) => path.isJSXElement()) || null;
    if (parentPath) {
      path.node.parentNode = parentPath.node;
      props.parentVar = path.node.parentNode.props.arguments.varName;
      console.log("props.parentVar", props.parentVar);
    } else path.node.parentNode = parentPath;

    // create new instance of component Object from component library:
    let compObj = SS[path.node.compType];
    // loop through props handled and assign them back to the current Node:
    for (let [key, value] of Object.entries(props)) {
      console.log("key:", key, ", value:", value);
      if (
        compObj.attributes.possibleVariants &&
        compObj.attributes.possibleVariants.includes(key)
      ) {
        // if key is one of the possibleVariants, assign variant to key
        path.node.variant = key;
      }
      // assign varibles to node.arguments:
      if (compObj.props.variables.hasOwnProperty(key))
        path.node.props.arguments[key] = value;
      // assign methods to node.methods:
      if (compObj.props.methods.hasOwnProperty(key))
        path.node.props.methods[key] = value;
    }
    return path.node;
  }

  // controls how props are converted into variables/id's

  // what's happening is when we pass in the Parent, we're getting fucky results
  function handleVars(compType, propsObj, path) {
    // console.log("handleVars propsObj:", propsObj);
    //console.log("SS[compType]", SS[compType]);
    if (propsObj.label || propsObj.id || propsObj.title) {
      // id NOT provided && the Type is NOT a Page: create id from label or title
      if (!propsObj.id && !SS[compType].attributes.isPage) {
        propsObj.id = createCompId(propsObj.label, compType, path);
      }
      propsObj.varName = createVarName(
        propsObj.label || propsObj.id || propsObj.title,
        compType,
        path
      );
    } else propsObj.varName = `${compType}_${seq}`; // component is a SELECT or special Button component
    //console.log("propsObj (handleVars):", propsObj);
    return propsObj;
  }

  // createCompId and createVarName are fairly similar and could possibly be refactored into the same function
  // and the
  // titles are autogenerated from label attribute, label is REQUIRED in JSSX
  function createCompId(label, type, path) {
    //  console.log("id: label:", label);
    const regex = /^[a-zA-Z_\s]+$/;
    if (label && regex.test(label)) {
      return `${
        "custpage_" +
        label
          .trim()
          .toLowerCase()
          .split(" ")
          .map((word, arr) => {
            if (word === arr[arr.length - 1] && word !== type) {
              // if last word does not end in the type, concat type to word:
              return (word += `_${type.toLowerCase()}`);
            } else return word;
          })
          .join("_")
      }`;
    } else {
      throw path.buildCodeFrameError(ERROR.illegalChar(label));
    }
  }

  // creates a constant variable name of each component
  function createVarName(string, type, path) {
    //console.log("varName: string:", string);
    const regex = /^[a-zA-Z_\s]+$/;
    // No special character, underscore is allowed
    if (regex.test(string)) {
      // console.log("string", string);
      return string
        .trim()
        .toLowerCase()
        .split(" ")
        .map((word, i, arr) => {
          // if NOT first word, make 1st letter uppercase
          if (i !== 0) {
            return word.charAt(0).toUpperCase() + word.slice(1, word.length);
          } else if (word === arr.at(-1) && word !== type) {
            // if last word does not end in the type, concat type to word:
            return (word += type);
          } else return word;
        })
        .join("");
    } else {
      throw path.buildCodeFrameError(ERROR.illegalChar(string));
    }
  }

  //////////////////////////////////////////////
  // EXPORTED FUNCTIONS to INDEX.JS
  function getSSComponentCalls(currNode, path) {
    console.log("currNode (SS Component Calls:", currNode);

    let suiteScriptSyntax;

    // PAGE COMPONENT:
    if (SS[currNode.compType].attributes.isPage) {
      console.log("PAGE COMPONENT!");
      suiteScriptSyntax = SS[currNode.compType].add(
        ui,
        currNode.props.arguments
      ); // initial syntax assignment
    } else {
      // NOT PAGE COMPONENT:
      // is COMPONENT a VARIANT?:
      if (currNode.variant) {
        console.log("button is variant");
        suiteScriptSyntax += `${SS[currNode.compType].props.methods[
          currNode.variant
        ](currNode.props.arguments)}`;
      } else {
        suiteScriptSyntax += `${SS[currNode.compType].add(
          currNode.props.arguments
        )}`;
      }
      // loop through other method calls (aside for .add() and variant methods):
      for (let [key, value] of Object.entries(currNode.props.methods)) {
        console.log("key:", key, "value:", value);
        suiteScriptSyntax += `${SS[currNode.compType].props.methods(
          currNode.props.arguments
        )}`;
      }
    }

    /*
    // ADD COMPONENT SYNTAX, arguments are spread because .add's parameters vary across components:
    // ADD Page component:
    if (SS[compInput.type].attributes.isPage) {
      console.log("PAGE COMPONENT!");
      suiteScriptSyntax = SS[compInput.type].add(ui, compProps); // initial syntax assignment
    } else {
      // whether the call is reset/submit/refresh they all accept the prop object and return string
      if (compInput.type === "Button") {
        console.log("comp is button");
        if (compProps.special) {
          // console.log("button is special");
          // console.log("compInput.type:", compInput.type);
          // console.log("propCallsObj:", propCallsObj);
          suiteScriptSyntax += `\n ${SS[compInput.type].props.methods[compProps.special](compProps)}`;
        } else {
          // is button, but not special button:
          suiteScriptSyntax += `\n ${SS[compInput.type].add(compProps)}`;
        }
      } else {
        // ADD non-Page component:
        console.log("NOT PAGE!");

        suiteScriptSyntax = `\n ${SS[compInput.type].add(compProps)}`;

        for (let [key, value] of Object.entries(propCallsObj)) {
          // console.log("key:", key, "value:", value);

          if (typeof key === "object") {
            //  console.log(SS[compInput.type].props.methods[key]);
            suiteScriptSyntax += `\n ${SS[compInput.type].props.methods[key](value)}`;
          }
        }
      }
    }
    */
    console.log("suiteScriptSyntax:", suiteScriptSyntax);
    return suiteScriptSyntax;
  }

  // Function NOT being used currently!
  function hasValidChildren(childNamesArr, compType, path) {
    // console.log(compType);
    // console.log(childNamesArr);
    if (
      !childNamesArr.every((child) =>
        SS[compType].attributes.possibleChildren.includes(child.name.name)
      )
    ) {
      throw path.buildCodeFrameError(
        `ERR: there is an invalid child in the component: '${compType}`
      );
    } else {
      // console.log("good kids");
    }
  }

  function handleProps(compType, propsArr, path) {
    let propsObj = {}; // new props object per component visit
    //console.log('comptype:', compType);
    // console.log("propsArr:", propsArr);
    propsArr.forEach((prop) => {
      const propName = prop.name.name;
      const propValNode = prop.value; // won't exist for some Nodes
      const propValExp = prop.value ? prop.value.expression : null; //  won't exist for some Nodes
      //  console.log("prop", prop);
      // valid prop of component in component library?
      //console.log(SS[comp].props.variables.hasOwnProperty(propName));
      /*
      if (!SS[compType].props.variables.hasOwnProperty(propName) && !SS[compType].props.methods.hasOwnProperty(propName)) {
        throw path.buildCodeFrameError(`ERR: The prop called: '${propName}' is NOT a valid prop in the component: '${compType}'`);
      }
      */
      // is prop duplicate?
      if (propsObj.hasOwnProperty(propName)) {
        throw path.buildCodeFrameError(
          `ERR: there is already an prop called: '${propName}' in the component: '${compType}. There cannot be duplicate props in a component'`
        );
      }
      // (ie. disable/mandatory/selected/hidden)
      if (propValNode === null) {
        propsObj[propName] = true;
        return;
      }
      // eg: prop="yourprop"
      if (t.isStringLiteral(propValNode)) {
        propsObj[propName] = propValNode.value;
        return;
      }
      // eg: prop={123}
      if (
        t.isJSXExpressionContainer(propValNode) &&
        t.isNumericLiteral(propValExp)
      ) {
        propsObj[propName] = propValExp.value;
        return;
      }
      // Props w. Bindings (IN FUNCTION SCOPE)
      // Could we use t.isBinding() instead?
      if (
        t.isJSXExpressionContainer(propValNode) &&
        t.isIdentifier(propValExp)
      ) {
        const identifiersObj = path.scope.bindings;
        // if the identifier object has props:
        if (Object.keys(identifiersObj).length !== 0) {
          let bindingIdNode = identifiersObj[propValExp.name].path.node;
          propsObj[propName] = bindingIdNode.init.value;
          return;
        }
        // Props w. Bindings (OUTSIDE FUNCTION SCOPE) how do????????
        // Could we use t.isBinding() for this?
      }
    });
    //console.log("handleProps:", propsObj);
    //console.log("handleVars return: ", handleVars(compType, propsObj, path));
    return handleVars(compType, propsObj, path);
  }
  //////////////////////////////////////////////////////////////
  /////////////////// PLUGIN ///////////////////////////////////
  //////////////////////////////////////////////////////////////

  // Global Object: this is where we track the components insertion order
  const pageObj = {}; // Tree structure that indicates the relationship between components
  const syntaxArr = []; // The queue of SS strings for replacing JSX
  const compStack = []; // Component sequence state
  let pageVar = "";
  let seq = 0;

  return {
    name: "jssx",
    visitor: {
      JSXElement(path) {
        // COMPONENT TYPE
        let compType = path.node.openingElement.name.name;
        path.node.compType = compType;
        console.log("NODE:", compType, ":", path.node);
        // PascalCase check:
        if (compType.charAt(0) !== compType.charAt(0).toUpperCase()) {
          throw path.buildCodeFrameError(
            `ERROR: jsx compType: ${path.node.compType} needs to be in PascalCase with the first letter capitalized!`
          );
        }

        // if no attributes, the syntax/component is void!
        let propsArr = path.node.openingElement.attributes;
        // console.log("propsArr", propsArr);

        // is any of this needed? maybe just a prop guard clause
        if (!propsArr)
          throw path.buildCodeFrameError(
            `ERROR: jssx compType: ${compType} does not have any attributes and therefore is void!`
          );

        let currNode = handleNode(path);
        console.log("handleNode NODE AFTER:", currNode);

        // set pageVar for child components to reference easily
        if (Object.keys(pageObj).length === 0)
          pageVar = currNode.props.arguments.varName;

        /*
        if (propsArr) {
          // assign pageObj its initial key/values
        

          // push all components to the stack
          compStack.push(currNode);

          // COMP IS NOT PAGE,
        
          if (Object.keys(pageObj).length !== 0) {
            console.log("comp is NOT page");

           
            // if current component has parent, assign currComp to it's children array
            if (currNode.arguments.varName) {
              // find the 1st comp that has a varName that matches the currComp's parentVar variable
              let parentComp = compStack.find((comp) => comp === currComp.props.variables.parentVar);
              console.log("parentComp:", parentComp);
              console.log("pageObj", pageObj);
              console.log("pageObj 1:", pageObj[parentComp]);
              pageObj[pageVar].attributes.children.push(currComp);
              // console.log("pageObj 2:", pageObj);

              // No parentVar Error:
            } else {
              throw path.buildCodeFrameError(`ERROR: jssx component: ${currComp.props.variables.varName}, does not have a parentVar`);
            }
            // console.log("pageObj", pageObj);
          } else {
            // COMP IS PAGE:
            console.log("comp is page");
            pageVar = currComp.props.variables.varName;
            pageObj[currComp.props.variables.varName] = currComp;
          }
          // No Props error:
        } else {
          throw path.buildCodeFrameError(`ERROR: jssx compType: ${compType} does not have any attributes and therefore is void!`);
        }
        */

        let ss = getSSComponentCalls(currNode, path);
        // console.log("typeof:", typeof ss, "\n ss: \n", ss);
        syntaxArr.push(ss);
        console.log(syntaxArr);
        console.log(syntaxArr.join(""));

        //path.replaceWithSourceString(`syntaxArr.join("")`);
        //path.skip();
      },
    },
  };
}

/*
Breadth First? Get Siblings, get Children, traverse children,


First Component:
1) Must be a Page
2) Must NOT have a sibling
3) Must have at least one child
4) Must have props

How do we know if the currComp is a child or a sibling of the prevComp?


Could we reattempt a recursive method?

- Initial Component. Is Page?
- Has Attributes? Handle Attributes.
- Add to Tree
- Has Sibling? VOID! Page cannot have siblings

- Get Children, handle Children.
- Has Children? Needs at least one child! Handle each Child
- Has Attributes? Handle Attributes.
- Add to Tree (from the Root/Page)





Have a stack for iterative implementations. Nodes can be pushed in and popped off the stack until there are no more nodes in the tree left to traverse








*/

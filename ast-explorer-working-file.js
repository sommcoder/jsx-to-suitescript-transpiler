exports.default = createPlugin;

const ui = "ui";

function createPlugin(babel) {
  const { types: t } = babel;

  //////////////////////////// SUITESCRIPT LIBRARY
  const SS = {
    // Page tracks state
    Page: {
      type: null,
    },
    Form: {
      // ui comes from outside the scope of the component function
      add: (ui, props) => {
        return `const ${props.varName} = ${ui}.createForm({
        title: '${props.title}',
      });`;
      },
      attributes: {
        isPage: true,
        canSelfClose: false,
        canHaveChildren: true,
        possibleChildren: ["Sublist", "Field", "Button", "Tab", "FieldGroup"],
        possibleParents: null,
      },
      props: {
        variables: {
          parentVar: null,
          varName: null,
          title: null,
          module: null,
          fileId: null,
          navBar: null,
        },
        methods: {
          module: (props) =>
            `${props.pageVar}.clientScriptModulePath = '${props.path}';`,
          fileId: (props) =>
            `${props.pageVar}.clientScriptFileId = '${props.id}';`,
          navBar: (props) =>
            `${props.pageVar}.clientScriptFileId = '${props.id}';`,
        },
      },
    },
    List: {},
    Assistant: {},
    Tab: {
      /*
      Tabs are special!
      
      -to enable tab to appear on your form, there must be at LEAST one component assigned to the tab
      -if < 2 tabs on form, the tab will not appear. this is SS logic, transpile normally!
      -Should throw WARNING for developer, but still transpile to SuiteScript^^^

      */
      add: (props) => {
        return `const ${props.varName} = ${props.pageVar}.addTab({
      id: '${props.id}',
      label: '${props.label}',
    });`;
      },
      attributes: {
        isPage: false,
        canSelfClose: false,
        canHaveChildren: true,
        possibleChildren: ["Field", "Button", "Sublist"],
        possibleParents: ["Form"],
      },
      props: {
        variables: {
          varName: null,
          parentVar: null,
          id: null,
          label: null,
          tab: null,
        },
        methods: {
          help: (props) => `${props.varName}.helpText = '${props.help}'`,
        },
      },
      // PascalCase
      FieldGroup: {
        add: (props) => {
          return `const ${props.varName} = ${props.pageVar}.addFieldGroup({
        id: '${props.id}',
        label: '${props.label}',
        ${props.tab ? `tab: ${props.tab}` : ""}
     })
    `;
        },
        attributes: {
          isPage: false,
          canSelfClose: false,
          canHaveChildren: true,
          possibleChildren: ["Field", "Button"],
          possibleParents: ["Form", "Assistant"],
        },
        props: {
          variables: {
            parentVar: null,
            varName: null,
            id: null,
            label: null,
            tab: null,
          },
          methods: {
            single: (props) => `${props.name}.isSingleColumn;`,
            collapsible: (props) => `${props.name}.isCollapsible = true;`,
            collapsed: (props) => `${props.name}.isCollapsed;`,
            borderHidden: (props) => `${props.name}.isBorderHidden = true;`,
          },
        },
      },
      Sublist: {
        add: (props) => {
          return `const ${props.varName} = ${props.pageVar}.addSublist({
      id: '${props.id}',
      label: '${props.label}',
 	  ${props.type ? `type: ${props.type},` : ""}
      ${props.tab ? `tab: ${props.tab}` : ""}
    });`;
        },
        attributes: {
          isPage: false,
          canSelfClose: false,
          canHaveChildren: true,
          possibleChildren: ["Field", "Button"],
          possibleParents: ["Form", "Assistant", "List", "Tab"],
        },
        props: {
          // props are what are encapsulated in each JSSX component tag
          variables: {
            label: null, // what the user wants to call the component
            type: null, // the type of component
            id: null, // the autogenerated id
            tab: null, // the tab variable that the component belongs to, inferred?
            parentVar: null,
            varName: null,
            pageVar: null,
          },
          methods: {
            markAll: (props) => `${props.varName}.addMarkAllButtons();`,
          },
        },
      },
      Field: {
        add: (props) => {
          return `const ${props.varName} = ${props.parentVar}.addField({
        id: '${props.id}',
        ${props.label ? `label: '${props.label}'` : `label: '${props.id}'`},
        ${props.type ? `type: '${props.type}',` : ""}
        ${props.source ? `source: '${props.source}',` : ""}
        ${props.container ? `container: '${props.container}',` : ""}
      })`;
        },
        attributes: {
          isPage: false,
          canSelfClose: true,
          canHaveChildren: true,
          possibleChildren: ["Select"],
          possibleParents: ["Form", "Assistant", "Tab", "Sublist", "List"],
          variants: ["secret", "totalling", "unique"],
        },
        props: {
          variables: {
            label: null,
            type: null,
            id: null,
            parentVar: null,
            parentId: null,
            pageVar: null,
            varName: null,
            source: null,
            container: null,
            breakType: null,
          },
          methods: {
            credential: (props) => {
              return `const ${props.varName} = ${
                props.pageVar
              }.addCredentialField({
        id: '${props.id}',
        restrictToDomains: '${props.domain}',
        ${props.scriptIds ? `restrictToScriptIds : '${props.scriptIds}'` : ""},
        ${props.restUser ? `restrictToCurrentUser : '${props.restUser}'` : ""},
        ${props.container ? `container: '${props.container}'` : ""}
        })`;
            },

            breakType: (props) => {
              return `${props.varName}.updateBreakType({
              breakType: ${props.breakType}
            });`;
            },
            // example:    size={height: 40, width: 50}
            size: (props) => {
              return `${props.varName}.updateDisplaySize({
                  height: ${props.size.height},
                  width: ${props.size.width}
              });`;
            },
            layout: (props) => {},
            alias: (props) => {},
            def: (props) => `${props.field}.defaultValue = '${props.def}';`,
            help: (props) => {
              return `${props.field}.setHelpText({
    		    help: '${props.help}'
  			    });
  		      `;
            },
            mandatory: (props) =>
              `${props.field}.isMandatory = ${props.mandatory};`,
            link: (props) => `${props.varName}.linkText = '${props.link}';`,
            max: (props) => `${props.field}.maxLength = ${props.max};`,
            padding: (props) => `${props.varName}.padding = ${props.padding}`,
            // secret is a special variant of field
            // it's parent MUST BE a page a secret field cannot be nested in non-page components

            // special Field component variants:
            // if nested in a fieldGroup or Tab, this parent will be inferred as the container and props.parentId will be the value container is given
            secret: (props) => {
              return `const ${props.varName} = ${
                props.pageVar
              }.addSecretKeyField({
              id: '${props.id}',
              ${props.label ? `label: '${props.label}'` : `label: ${props.id}`},
              ${
                props.scriptIds
                  ? `restrictToScriptIds: '${props.scriptIds}',`
                  : ""
              }
              ${
                props.restUser
                  ? `restrictToCurrentUser: '${props.restUser}',`
                  : ""
              },
               ${props.container ? `container: '${props.parentId}',` : ""},
            });
  `;
            },
            // the id of the field:
            totalling: (props) => {
              return `${props.sublistVar}.updateTotallingField({
      id: '${props.id}',
})`;
            },
            unique: (props) => {
              return `${props.sublistVar}.updateUniqueFieldId({
  id: '${props.id}',
})`;
            },
          },
        },
      },

      Select: {
        add: (props) => {
          return `${props.fieldVar}.addSelectOption({
                  value : '${props.value}',
                  text : '${props.text}',
                  ${props.isSelected ? `isSelected: true` : ""}
            });
`;
        },
        attributes: {
          isPage: false,
          canSelfClose: true,
          canHaveChildren: false,
          possibleChildren: null,
          possibleParents: ["Field"],
        },
        props: {
          variables: {
            parent: null,
            isSelected: false,
            value: null,
            text: null,
            parentVar: null, // can only be Field anyways
          },
        },
      },
      Button: {
        add: (props) => {
          if (props.parent === "Form") {
            return `const ${props.varName} = ${props.pageVar}.addButton({
                  id: '${props.id}',
                  ${
                    props.label
                      ? `label: '${props.label}'`
                      : `label: '${props.id}'`
                  },
                  ${props.func ? `func: ${props.func}` : ""}
              });`;
          }
          if (props.parent === "Sublist") {
            return `const ${props.varName} = ${props.parentVar}.addButton({
                  id: '${props.id}',
                  label: '${props.label}',
              });`;
          }
        },
        attributes: {
          isPage: false,
          canSelfClose: true,
          canHaveChildren: false,
          possibleChildren: null,
          possibleParents: ["Field", "Form", "Assistant", "Sublist"],
          variants: ["hidden", "submit", "reset"],
        },
        props: {
          variables: {
            parent: null,
            label: null,
            id: null,
            parentVar: null,
            varName: null, // the variable name of this button component
            pageVar: null, // the variable name of the page the button belongs to
            func: null,
          },
          methods: {
            disabled: (props) =>
              `${props.buttonVar}.clientScriptModulePath = '${props.path}';`,
            hidden: (props) =>
              `${props.buttonVar}.clientScriptFileId = '${props.id}';`,
            // if submit, id disregarded, label accepted only, default: "Submit Button"
            submit: (props) => {
              return `const ${props.varName || "submitBtn"} = ${
                props.pageVar
              }.addSubmitButton({
            ${
              props.label ? `label: '${props.label}'` : `label: "Submit Button"`
            },
          });
          `;
            },
            // if reset, id disregarded, label accepted only, default: "Reset Button"
            // parent MUST be a Page
            reset: (props) => {
              return `const ${props.varName || "resetBtn"} = ${
                props.pageVar
              }.addResetButton({
            ${
              props.label ? `label: '${props.label}'` : `label: "Reset Button"`
            },
          });
          `;
            },
            // if reset, id AND label disregarded,
            refresh: (props) =>
              `const refreshBtn = ${props.sublistVar}.addRefreshButton();`,
          },
        },
      },
      // creates the Page, whether thats a Form, List or Assistant
      // always gets called in the plugin
      Write: (res, props) => {
        return `
    ${res}.writePage({
        pageObject: ${props.pageVar}
    })  
`;
      },
    },
  };
  ////////////////////////////////////////////////////////////////////
  ////////////////////////// UTILITY FUNCTIONS ///////////////////////

  const ERROR = {
    illegalChar: (label) =>
      `ERROR: jsx label: ${label} contains special characters that are not permitted`,
    invalidComp: (comp) =>
      `ERR: the jsx component: ${comp}, is NOT included in the ss library. Refer to docs to see included components`,
  };

  function createCompObj(type, attrObj, path) {
    try {
      let id = null;
      let varName;
      let props = handleProps(type, attrObj, path);
      console.log("props:", props);
      // create new instance of component Object
      let compObj = SS[type];
      console.log("compObj", compObj);

      // loop through props handled, and assign them to our compoent object:
      for (let [key, value] of Object.entries(props)) {
        console.log("key", key, "value", value);
        compObj.props.variables = value;
      }

      console.log("compObj", compObj);

      // if none of the below, must be SELECT component, which doesn't need a label/id/title/varName
      //console.log("varName:", props.varName);
      let parentPath = path.findParent((path) => path.isJSXElement()) || null;
      console.log("parentPath:", parentPath);

      // if parent exists:
      if (parentPath) {
        console.log(
          "comp type:",
          type,
          "& parent.node:",
          parentPath.node.openingElement
        );
        let parentAttrsArr = parentPath.node.openingElement.attributes;
        console.log(parentAttrsArr);
        compObj.parentType = parentPath.node.openingElement.name.name;

        // this is expensive for JUST getting the varName of the parent....?
        compObj.parentVar = handleProps(
          parentPath.node.openingElement.name.name,
          parentAttrsArr,
          path
        ).varName;
      }
      /*
/// whats the point in siblings again???? only thing that matters is ancestry here, right?
      let siblingsArr = [
        ...path
          .getAllNextSiblings()
          .filter((sib) => sib.node.type !== "JSXText")
          .map((sib) => sib.node)
      ];
      */
      let childArr = [
        ...path.node.children
          .filter((child) => child.type !== "JSXText")
          .map((child) => child.openingElement),
      ];
      //console.log("childArr", childArr);

      return {
        [type]: compObj,
        // siblings: siblingsArr,
        children: childArr,
      };
    } catch (err) {
      console.log("ERROR:", err);
    }
  }

  // controls how props are converted into variables/id's
  function handleVars(type, props, path) {
    console.log("handleVars props:", props);
    if (props.label || props.id || props.title) {
      // id NOT provided && the Type is NOT a Page: create id from label or title
      if (!props.id && !SS[type].attributes.isPage) {
        props.id = createCompId(props.label, type, path);
      }
      props.varName = createVarName(
        props.label || props.id || props.title,
        type,
        path
      );
    } else props.varName = null; // component is a SELECT or special Button component
    return props;
  }
  // createCompId and createVarName are fairly similar and could possibly be refactored into the same function
  // and the
  // titles are autogenerated from label attribute, label is REQUIRED in JSSX
  function createCompId(label, type, path) {
    //  console.log("id: label:", label);
    const regex = /^[a-zA-Z_\s]+$/;
    if (label && regex.test(label)) {
      return `${
        "custpage_" +
        label
          .trim()
          .toLowerCase()
          .split(" ")
          .map((word, i, arr) => {
            if (word === arr.at(-1) && word !== type) {
              // if last word does not end in the type, concat type to word:
              return (word += `_${type.toLowerCase()}`);
            } else return word;
          })
          .join("_")
      }`;
    } else {
      throw path.buildCodeFrameError(ERROR.illegalChar(label));
    }
  }

  // creates a constant variable name of each component
  function createVarName(string, type, path) {
    //console.log("camel: string:", string);
    const regex = /^[a-zA-Z_\s]+$/;
    // No special character, underscore is allowed
    if (regex.test(string)) {
      // console.log("string", string);
      return string
        .trim()
        .toLowerCase()
        .split(" ")
        .map((word, i, arr) => {
          // if NOT first word, make 1st letter uppercase
          if (i !== 0) {
            return word.charAt(0).toUpperCase() + word.slice(1, word.length);
          } else if (word === arr.at(-1) && word !== type) {
            // if last word does not end in the type, concat type to word:
            return (word += type);
          } else return word;
        })
        .join("");
    } else {
      throw path.buildCodeFrameError(ERROR.illegalChar(string));
    }
  }
  //////////////////////////////////////////////
  // EXPORTED FUNCTIONS to INDEX.JS
  function getSSComponentCalls(compInput, path) {
    // if Page component, handle differently

    console.log("compInput", compInput);
    console.log("PROPS", compInput.props);

    // an array of the names of props that add syntax (ie. are functions/objects)
    let propCallsObj = {
      varName: compInput.props.varName,
      pageVar: pageVar,
      parentVar: parent,
    }; // gets varName by default
    let addPropsObj = {};
    let suiteScriptSyntax;

    // categorize prop keys by whether they are part of the add Call or Other SS Calls:
    for (let [key, value] of Object.entries(compInput.props)) {
      console.log("CompInput Prop Loop", "key:", key, "value:", value);
      if (typeof SS[compInput.type].props[key] !== "object") {
        console.log(
          "SS[compInput].props.attributes",
          SS[compInput.type].attributes
        );

        if (
          SS[compInput.type].attributes.hasOwnProperty("options") &&
          SS[compInput.type].attributes.options.includes(key)
        ) {
          propCallsObj.special = key;
        } else {
          propCallsObj[key] = value;
        }
      } else {
        addPropsObj[key] = value;
      }
    }

    console.log("propCallsObj", propCallsObj);
    console.log("addPropsObj", addPropsObj);

    // ADD COMPONENT SYNTAX, arguments are spread because .add's parameters vary across components:
    // ADD Page component:
    if (SS[compInput.type].attributes.isPage) {
      console.log("PAGE COMPONENT!");
      suiteScriptSyntax = SS[compInput.type].add(ui, addPropsObj); // initial syntax assignment
    } else {
      // whether the call is reset/submit/refresh they all accept the prop object and return string
      if (compInput.type === "Button") {
        console.log("comp is button");
        if (propCallsObj.special) {
          // console.log("button is special");
          // console.log("compInput.type:", compInput.type);
          // console.log("propCallsObj:", propCallsObj);
          suiteScriptSyntax += `\n ${SS[compInput.type].props.methods[
            propCallsObj.special
          ](addPropsObj)}`;
        } else {
          // is button, but not special button:
          suiteScriptSyntax += `\n ${SS[compInput.type].add(addPropsObj)}`;
        }
      } else {
        // ADD non-Page component:
        console.log("NOT PAGE!");
        console.log("addPropsObj", addPropsObj);
        suiteScriptSyntax = SS[compInput.type].add(addPropsObj);

        for (let [key, value] of Object.entries(propCallsObj)) {
          console.log("key:", key, "value:", value);

          if (typeof key === "object") {
            console.log(SS[compInput.type].props.methods[key]);
            suiteScriptSyntax += SS[compInput.type].props.methods[key](value);
          }
        }
      }
    }
    console.log("suiteScriptSyntax: \n", suiteScriptSyntax);
  }

  function hasValidChildren(childrenNamesArr, comp) {
    return childrenNamesArr.every((child) =>
      SS[comp].attributes.possibleChildren.includes(child)
    );
  }

  function handleProps(comp, propsArr, path) {
    let properties = {}; // new props object per component visit

    propsArr.forEach((prop) => {
      const propName = prop.name.name;
      const propValNode = prop.value; // won't exist for some Nodes
      const propValExp = prop.value ? prop.value.expression : null; //  won't exist for some Nodes

      // valid prop of component in component library?
      console.log(SS[comp].props.hasOwnProperty(propName));
      if (
        !SS[comp].props.variables.hasOwnProperty(propName) &&
        !SS[comp].props.methods.hasOwnProperty(propName)
      ) {
        throw path.buildCodeFrameError(
          `ERR: The prop called: '${propName}' is NOT a valid prop in the component: '${comp}'`
        );
      }
      // is prop duplicate?
      if (properties.hasOwnProperty(propName)) {
        throw path.buildCodeFrameError(
          `ERR: there is already an prop called: '${propName}' in the component: '${comp}. There cannot be duplicate props in a component'`
        );
      }
      // (ie. disable/mandatory/selected/hidden)
      if (propValNode === null) {
        properties[propName] = true;
        return;
      }
      // eg: prop="yourprop"
      if (t.isStringLiteral(propValNode)) {
        properties[propName] = propValNode.value;
        return;
      }
      // eg: prop={123}
      if (
        t.isJSXExpressionContainer(propValNode) &&
        t.isNumericLiteral(propValExp)
      ) {
        properties[propName] = propValExp.value;
        return;
      }
      // Props w. Bindings (IN FUNCTION SCOPE)
      // Could we use t.isBinding() instead?
      if (
        t.isJSXExpressionContainer(propValNode) &&
        t.isIdentifier(propValExp)
      ) {
        const identifiersObj = path.scope.bindings;
        // if the identifier object has props:
        if (Object.keys(identifiersObj).length !== 0) {
          let bindingIdNode = identifiersObj[propValExp.name].path.node;
          properties[propName] = bindingIdNode.init.value;
          return;
        }
        // Props w. Bindings (OUTSIDE FUNCTION SCOPE) how do????????
        // Could we use t.isBinding() for this?
      }
    });
    //console.log("createVars", handleVars(comp, properties, path));
    return handleVars(comp, properties, path);
  }
  //////////////////////////////////////////////////////////////
  /////////////////// PLUGIN ///////////////////////////////////
  //////////////////////////////////////////////////////////////

  // Global Object: this is where we track the components insertion order
  const pageArr = []; // structure that indicated relationships
  const syntaxArr = []; // the queue of SS strings for replacing JSX
  let pageVar = "";

  return {
    name: "jssx",
    visitor: {
      JSXElement(path) {
        let compType = path.node.openingElement.name.name;
        // console.log("compType:", compType);
        let currComp = {};
        // PascalCase check:
        if (compType.charAt(0) !== compType.charAt(0).toUpperCase()) {
          throw path.buildCodeFrameError(
            `ERROR: jsx compType: ${compType} needs to be in PascalCase with the first letter capitalized!`
          );
        }

        // if no attributes, the syntax/component is void
        let compAttrs = path.node.openingElement.attributes;
        if (compAttrs) {
          // assign pageObj its initial key/values
          currComp = createCompObj(compType, compAttrs, path);

          // first component is Page:
          // console.log(pageArr.length);
          if (pageArr.length === 0) pageVar = currComp.props.varName;

          pageArr.push({ [compType]: currComp });
        } else {
          throw path.buildCodeFrameError(
            `ERROR: jsx compType: ${compType} does not have any attributes and therefore must be void!`
          );
        }

        console.log("pageArr", pageArr);

        getSSComponentCalls(currComp, path);
      },
    },
  };
}
